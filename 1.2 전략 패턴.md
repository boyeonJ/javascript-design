## 전략 패턴

행위 패턴(Behavioral Pattern) 중 하나로, 알고리즘(혹은 동작)을 **캡슐화**하여 런타임에 선택·교체할 수 있도록 만드는 설계 기법입니다. 

- Context(문맥): 언제·어떤 상황에 동작을 실행할지
- Strategy(전략): 실제로 어떻게 동작할지

### 등장 배경: 해결하고자 했던 문제

여러 알고리즘이 한 군데에 모두 놓여져 있는 코드가 있습니다. 이 코드는 if-else, switch 문을 통해 직접 분기 처리합니다. 이러한 코드는 새로운 알고리즘이 추가가 될 때마다 코드를 **수정해야** 합니다. 이는 OCP 원칙에 어긋납니다.

이를 해결하기 위해서 공통 행위는 한곳에 모아두고 구체적인 알고리즘은 외부에서 주입하여 변경에 유연하면서 기존 코드는 수정되지 않는 방법이 등장했습니다. 이러한 패턴이 전략 패턴입니다.

![image](https://github.com/user-attachments/assets/6b4547e8-6fb2-42db-b2b1-522a0902bf74)


### 핵심 아이디어

- **알고리즘을 인터페이스(또는 추상 클래스)로 추출**
    
    행위를 `Strategy`라는 개념으로 추상화하고, 구체적인 알고리즘들은 `ConcreteStrategyA`, `ConcreteStrategyB`처럼 별도의 클래스로 분리합니다.
    
- **클라이언트는 인터페이스만 바라본다**
  클라이언트 객체(“Context”라고 부릅니다)는 `Strategy` 인터페이스를 가진 **“행위(behavior)를 위임할 객체”**를 **멤버 변수**로 가지고 있습니다. 그리고 **멤버 변수의 알고리즘**(인터페이스)를 언제 실행시킬지 구현해 줍니다.

- 실행시점에 전략을 context에 주입
    
    

### 실제 활용

공통 인터페이스 정의

```jsx
// PaymentStrategy.ts
export interface PaymentStrategy {
  pay(amount: number, orderId: string): Promise<PaymentResult>;
}
```

구체 전략 클래스

```jsx
// CreditCardStrategy.ts
export class CreditCardStrategy implements PaymentStrategy {
  async pay(amount: number, orderId: string): Promise<PaymentResult> {
    // 1) 카드 정보 검증 (예: 서버 내 저장된 카드 토큰을 이용)
    // 2) PG사 API 호출 (ex: /v1/payments/credit 요청)
    // 3) 응답을 PaymentResult 형태로 가공
    // 4) 에러 발생 시, 특정 예외 던지기
    return { success: true, transactionId: 'CC123456' };
  }
}

// PaypalStrategy.ts
export class PaypalStrategy implements PaymentStrategy {
  async pay(amount: number, orderId: string): Promise<PaymentResult> {
    // 1) PayPal 접속 토큰 획득
    // 2) PayPal 결제 세션 생성
    // 3) 사용자가 승인한 후, 결제 확정
    return { success: true, transactionId: 'PP987654' };
  }
}

// TossPayStrategy.ts
export class TossPayStrategy implements PaymentStrategy {
  async pay(amount: number, orderId: string): Promise<PaymentResult> {
    // 1) Toss API 인증
    // 2) tossCharge API 호출
    // 3) 결과 파싱 후 리턴
    return { success: true, transactionId: 'TP246810' };
  }
}
```

컨텍스트 클래스

```jsx
// PaymentService.ts
import { PaymentStrategy } from './PaymentStrategy';

export class PaymentService {
  private strategy: PaymentStrategy;

  constructor(strategy: PaymentStrategy) {
    this.strategy = strategy;
  }

  // 런타임에 전략을 교체할 수 있음
  setStrategy(strategy: PaymentStrategy) {
    this.strategy = strategy;
  }

  async processPayment(amount: number, orderId: string) {
    try {
      // 1) 공통 Validation (주문 상태, 재고 확인 등)
      // 2) 실제 결제 호출
      const result = await this.strategy.pay(amount, orderId);
      // 3) 결과에 따른 후처리 (주문 상태 변경, 알림 발송 등)
      return result;
    } catch (error) {
      // 공통 예외 처리 (로그, 리트라이 로직, 에러 응답 포맷 등)
      throw error;
    }
  }
}
```

실제 사용

```jsx
// 예: 사용자가 “카카오페이”를 선택했을 때
const kakaoStrategy = new KakaoPayStrategy(/* 필요 옵션들 */);
const paymentService = new PaymentService(kakaoStrategy);
const result = await paymentService.processPayment(50000, 'ORDER-1234');
console.log(result); // { success: true, transactionId: ... }

// 선택을 바꿔서 “신용카드”로 결제할 때
paymentService.setStrategy(new CreditCardStrategy(/*options*/));
await paymentService.processPayment(50000, 'ORDER-1234');

```
