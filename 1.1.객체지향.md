# 객체지향

## 객체지향 특징

### 1. 개방 폐쇄 원칙(OCP, Open-Closed Principle)

"확장에는 열려 있어야 한다(Open for extension), 하지만 변경에는 닫혀 있어야 한다(Closed for modification)"

객체를 직접 수정하지 않으면서 기능을 추가할 수 있도록 구조화함으로써, **변경으로 인한 버그 리스크🔻**를 줄이고 **유지보수성을 높이는(다형성과 확장을 극대화)🔺** 설계 원칙입니다.

적용하는 방법은 추상화(interface/abstract) 입니다.

### 2. 의존성 역전 원칙(DIP, Dependency inversion principle)
"고수준(what) 코드는 저수준(how)에 직접 의존하지 말고, 둘 다 ‘추상화(인터페이스)’에 의존하게 만들어라. 그렇게 함으로써 둘 사이의 결합을 끊자."

> '의존한다'의 의미는 보통 import / new / 메서드 호출로 드러납니다.

> 고수준 = ‘무엇을/왜’를 말하는 층, 저수준 = ‘어떻게’를 다루는 층.
높낮이는 기술 난이도가 아니라 비즈니스 의미에의 근접도를 말합니다.

고수준(what) 코드는 저수준(how)에 직접 의존하지 않고, 양쪽 모두 ‘추상화(인터페이스/포트)’에 의존하도록 만들어 교체 용이성 🔺, 테스트 용이성 🔺, 환경 전환 비용 🔻 을 달성하는 설계 원칙.

```javascript
// 1) Port: 정책이 원하는 능력(런타임에 사라지므로 타입만)
export interface PaymentGateway { charge(amount: number, token: string): Promise<string> }

// 2) 고수준: 인터페이스 타입만 본다 (구현 몰라요)
export class CheckoutService {
  constructor(private pay: PaymentGateway) {}
  checkout(a: number, t: string) { return this.pay.charge(a, t) }
}

// 3) 저수준 구현: 어댑터
export class StripeGateway implements PaymentGateway {
  constructor(private sdk: any) {}
  charge(a: number, t: string) { return this.sdk.charge(a, t) }
}

// 조립(외부): 어떤 구현을 쓸지 여기서만 결정
const svc = new CheckoutService(new StripeGateway(stripeSdk));

```


# 객체지향 디자인 패턴

## 디자인 패턴 분류

### 1. 생성 패턴

객체 생성에 관련된 패턴

### 2. 구조 패턴

클래스와 객체의 조합 방법을 다루는 패턴으로, "더 큰 구조"를 형성하고 유지보수성을 높이는 데 사용

### 3. 행위 패턴

객체 간의 상호작용을 다루는 패턴으로, 객체 간의 책임 "분배"와 소통 방법을 정의
