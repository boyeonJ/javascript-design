# 표로 정리해보기
언제 어떤 상황의 문제를 해결하고자 해당 디자인 패턴을 활용하면 좋은지에 대해 간단하게 표로 정리해봅시다.

## 생성패턴
| 패턴명                  | 설명                       | 사용 상황 예시                        |
| -------------------- | ------------------------ | ------------------------------- |
| **Singleton**        | 오직 하나의 인스턴스만 존재하도록 보장    | 전역 설정, DB 연결                    |
| **Factory Method**   | 객체 생성을 서브클래스에 위임         | 다양한 하위 클래스를 유연하게 생성해야 할 때       |
| **Abstract Factory** | 관련된 객체 집합을 생성하는 인터페이스 제공 | UI 테마별 위젯 팩토리 등                 |
| **Builder**          | 복잡한 객체를 단계적으로 생성         | 객체 생성 옵션이 많을 때 (예: Form, Query) |
| **Prototype**        | 객체를 복사해서 생성              | 성능상 new보다 clone이 빠를 때           |

## 구조패턴
| 패턴명           | 설명                            | 사용 상황 예시         |
| ------------- | ----------------------------- | ---------------- |
| **Adapter**   | 인터페이스를 변환하여 기존 클래스 재사용 가능하게 함 | 레거시 코드 호환        |
| **Bridge**    | 구현과 추상화의 분리                   | 플랫폼 별 UI 렌더링 구조  |
| **Composite** | 객체들을 트리 구조로 구성하여 일관된 방식으로 다룸  | UI 컴포넌트 트리       |
| **Decorator** | 런타임에 객체에 기능을 추가               | 로깅, 인증 추가 등      |
| **Facade**    | 복잡한 서브시스템을 단순화                | 외부 API 통합 래퍼     |
| **Flyweight** | 메모리 절약을 위해 객체를 공유             | 텍스트 편집기 글자 객체 등  |
| **Proxy**     | 접근 제어나 지연 초기화 등을 위임           | 가상 프록시, 보호 프록시 등 |

## 행위패턴
| 패턴명                         | 설명                             | 사용 상황 예시          |
| --------------------------- | ------------------------------ | ----------------- |
| **Chain of Responsibility** | 요청을 처리할 여러 객체를 체인으로 연결         | 이벤트 핸들링, 미들웨어     |
| **Command**                 | 요청을 캡슐화하여 저장, 실행, 취소 등 가능하게    | Undo/Redo 기능      |
| **Interpreter**             | 언어나 문법 구조를 해석                  | 수식 계산기, DSL       |
| **Iterator**                | 컬렉션 요소를 순회하는 방법 제공             | forEach, next() 등 |
| **Mediator**                | 객체 간 직접 통신 대신 중재자에 의해 조율       | 채팅방 메시지 분배 등      |
| **Memento**                 | 객체의 상태를 저장 및 복원                | 게임 저장 기능          |
| **Observer**                | 객체 변화에 따라 자동으로 알림              | 이벤트 리스너, 상태 관리    |
| **State**                   | 상태에 따라 행동이 달라지는 객체             | 상태별 UI 또는 동작      |
| **Strategy**                | 알고리즘을 런타임에 교체 가능               | 정렬 방식 변경 등        |
| **Template Method**         | 알고리즘의 구조는 고정, 일부 단계는 서브클래스에 위임 | 훅(hook) 메서드 제공    |
| **Visitor**                 | 구조 변경 없이 새로운 기능 추가             | 복잡한 객체 구조에 연산 추가  |


# 더 나아가서
어떤 냄새가 나는 코드에서 활용하면 좋은지, 그리고 유사항 패턴끼리의 차이점은 무엇인지 정리해봅시다.

| 패턴명                  | 코드 냄새 (적용 타이밍)                               | 유사한 패턴과 차이점                                                               |
| -------------------- | ----------------------------------------------- | ---------------------------------------------------------------------------- |
| **Singleton**        | 전역 변수가 여기저기 퍼져 있고, 인스턴스가 여러 개 생성될 위험이 있을 때      | - vs **Static Class**: 상태 보존 가능 <br> - vs **DI Container**: 유연성은 떨어짐         |
| **Factory Method**   | 생성 로직이 클라이언트 코드에 섞여 있을 때 (`new`가 자주 반복)         | - vs **Abstract Factory**: 개별 제품 생성 <br> - vs **Builder**: 생성 과정의 세분화는 약함    |
| **Abstract Factory** | 제품군(관련 객체들)을 함께 생성해야 할 때, 서로 맞는 객체들을 함께 쓰고 싶을 때 | - vs **Factory Method**: 개별 클래스 하나 생성 <br> - vs **Prototype**: 복제 방식         |
| **Builder**          | 생성자에 매개변수가 너무 많을 때 (telescoping constructor)    | - vs **Factory Method**: 순차적 생성 지원<br> - vs **Prototype**: 복사는 아님            |
| **Prototype**        | 객체를 복제해서 빠르게 생성해야 할 때, 복잡한 초기화가 자주 반복될 때        | - vs **Builder**: 직접 조립함<br> - vs **Factory**: 새로 생성이 아닌 복제                  |
| **Adapter**          | 기존 API가 새 요구사항에 맞지 않을 때 / 외부 라이브러리와 호환이 안 될 때   | - vs **Decorator**: 기능을 추가하는 목적 아님 <br> - vs **Proxy**: 동작은 그대로, 인터페이스 변환    |
| **Decorator**        | 조건문으로 기능을 덕지덕지 추가하고 있을 때                        | - vs **Adapter**: 인터페이스 변환 X<br> - vs **Proxy**: 기능 추가 목적이 다름                |
| **Strategy**         | 조건문(switch, if-else)이 알고리즘 변경을 제어할 때            | - vs **State**: 상태 기반이 아님<br> - vs **Template Method**: 상속 대신 위임 사용          |
| **Observer**         | 한 객체의 변경이 다른 객체에 영향을 줄 때, 강한 결합이 문제일 때          | - vs **Mediator**: 양방향 다대다 통신은 Mediator가 낫다                                  |
| **State**            | 조건문으로 상태에 따른 행동을 나눌 때 (`if state === ...`)      | - vs **Strategy**: 상태 기반 동작 <br> - vs **Observer**: 반응형이 아니라 주체가 상태를 스스로 전환함 |
