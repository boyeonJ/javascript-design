## 옵저버 패턴

구조 패턴(Behavioral Pattern) 중 하나로, 한 객체(Subject)의 상태 변화가 있을 때, 그와 연관된 여러 객체(Observers)에 자동으로 통지되어 동작을 수행하도록 ****만드는 설계 기법입니다.

즉, 주체 객체(Subject)는 자신을 관찰하는 옵저버 목록을 관리하고, 상태가 변경되면 등록된 모든 옵저버에게 알림을 보내어 필요한 처리를 위임합니다.

### 등장 배경

뉴스 구독 시스템이 있습니다. 이 서비스는 새로운 기사가 등록되면 사용자에게 메일, sns, push 알림을 보내야 합니다(ISP 원칙에 어긋남). 이를 위해 새 기사 등록 로직 내부에 직접 분기처리를 해주어야 합니다.

따라서 새로운 알림 기능이 추가된다면 개발자는 기사 등록 코드를 직접 열어 새로운 코드를 수정해야 합니다. (OCP 원칙에 어긋남) 이러한 문제를 해결하고자 주체 코드(Subject)는 전혀 수정하지 않고, 수정시 변경이 필요한 부분들에게(Observer)에게 알림을 전달하여 추가 로직을 위임하는 Observer 패턴이 등장하였습니다.

### 핵심 아이디어

1. Subject(주체 인터페이스)를 구현합니다. 아래와 같이 옵저버를 관리하는 기능들이 포함되어 있습니다.
    - `attach(observer: Observer): void`
    - `detach(observer: Observer): void`
    - `notify(data?: any): void`
2. ConcreteSubject(구체 주체 클래스)
    - 내부에 `observers: Observer[]` 배열을 가지고, `attach`와 `detach`를 통해 관리
    - 상태 변경 메서드(`setState` 등)를 통해 새로운 상태가 들어오면 `notify` 호출
    - `notify()`는 `this.observers` 배열 순회하며, 각 옵저버의 `update(this, data)`를 호출
3. Observer(옵저버 인터페이스)
    - `update(subject: Subject, data?: any): void`
    - 주체가 `notify`할 때 호출되며, “주체 자신(reference) + (선택적으로) 상태값 데이터”를 전달받음
4. ConcreteObserver(구체 옵저버 클래스)
    - `update(subject: Subject, data?: any)`를 구현하여, 주체로부터 받은 데이터에 따라 자신이 해야 할 로직을 수행
    - 예: 메일 전송, 푸시 알림, 화면 컴포넌트 리렌더링, 로그 기록 등

### 실제 활용

인터페이스 정의

```jsx
// Observer.ts
export interface Observer {
  /**
   * 주체(Subject)가 상태 변경 시 호출되는 메서드
   * @param subject 상태가 변경된 주체 객체 자신
   * @param data   변경된 상태(예: 새 기사 정보)
   */
  update(subject: Subject, data?: any): void;
}

// Subject.ts
export interface Subject {
  attach(observer: Observer): void;
  detach(observer: Observer): void;
  notify(data?: any): void;
}
```

구체 주제 클래스

```jsx
// NewsPublisher.ts
import { Subject } from './Subject';
import { Observer } from './Observer';

export class NewsPublisher implements Subject {
  private observers: Observer[] = [];
  private latestNews: string = '';

  // 옵저버 등록
  attach(observer: Observer): void {
    this.observers.push(observer);
  }

  // 옵저버 해제
  detach(observer: Observer): void {
    this.observers = this.observers.filter(obs => obs !== observer);
  }

  // 직접 상태를 변경할 때 호출
  setNews(news: string): void {
    this.latestNews = news;
    this.notify(news);
  }

  // 상태 변경 시 모든 옵저버에게 알림
  notify(data?: any): void {
    for (const observer of this.observers) {
      observer.update(this, data);
    }
  }

  // 옵저버가 필요하다면 주체의 상태 호출용 메서드 제공
  getNews(): string {
    return this.latestNews;
  }
}
```

구체 옵저버 클래스

```jsx
// EmailSubscriber.ts
import { Observer } from './Observer';
import { Subject } from './Subject';

export class EmailSubscriber implements Observer {
  private emailAddress: string;

  constructor(email: string) {
    this.emailAddress = email;
  }

  update(subject: Subject, data?: any): void {
    // 예: 주체가 NewsPublisher 타입인 경우만 처리하도록 캐스팅
    const publisher = subject as any;
    const newArticle = data || publisher.getNews();

    // 실제 메일 전송 로직 대체 예시
    console.log(`[메일 전송] ${this.emailAddress} 님께 "${newArticle}" 뉴스 발송 완료`);
    // → 여기서 nodemailer나 실제 메일 API를 호출할 수 있음
  }
}

// PushSubscriber.ts
import { Observer } from './Observer';
import { Subject } from './Subject';

export class PushSubscriber implements Observer {
  private deviceToken: string;

  constructor(token: string) {
    this.deviceToken = token;
  }

  update(subject: Subject, data?: any): void {
    const publisher = subject as any;
    const newArticle = data || publisher.getNews();

    // 실제 푸시 알림 로직 대체 예시
    console.log(`[푸시 알림] 디바이스(${this.deviceToken})에 "${newArticle}" 푸시 전송 완료`);
    // → 여기에 FCM, APNS 등 실제 푸시 서비스 호출 가능
  }
}
```

실제 사용 

```jsx
// main.ts
import { NewsPublisher } from './NewsPublisher';
import { EmailSubscriber } from './EmailSubscriber';
import { PushSubscriber } from './PushSubscriber';

function main() {
  // 1) 주체 객체 생성
  const newsPublisher = new NewsPublisher();

  // 2) 옵저버(구독자) 생성 및 주체에 등록
  const emailSub1 = new EmailSubscriber('user1@example.com');
  const emailSub2 = new EmailSubscriber('user2@example.com');
  const pushSub = new PushSubscriber('DEVICE_TOKEN_ABC123');

  newsPublisher.attach(emailSub1);
  newsPublisher.attach(emailSub2);
  newsPublisher.attach(pushSub);

  // 3) 뉴스가 등록될 때마다 주체가 옵저버에게 자동으로 통지
  newsPublisher.setNews('오늘 날씨는 맑음, 이상 기온 주의하세요!');

  // 콘솔 출력:
  // [메일 전송] user1@example.com 님께 "오늘 날씨는 맑음, 이상 기온 주의하세요!" 뉴스 발송 완료
  // [메일 전송] user2@example.com 님께 "오늘 날씨는 맑음, 이상 기온 주의하세요!" 뉴스 발송 완료
  // [푸시 알림] 디바이스(DEVICE_TOKEN_ABC123)에 "오늘 날씨는 맑음, 이상 기온 주의하세요!" 푸시 전송 완료

  // 4) 특정 옵저버 해제도 자유롭게 가능
  newsPublisher.detach(emailSub2);

  // 뉴스 업데이트(두 번째)
  newsPublisher.setNews('속보: 30도 넘는 무더위, 자외선 차단 필수!');
  // 이제 emailSub2는 해제되어 있고, emailSub1와 pushSub에게만 알림이 전송됨
}

main();
```
