## 데코레이터 패턴

구조 패턴(Structural Pattern) 중 하나로, 기존 객체에 **새로운 책임이나 기능**을 기존 객체를 wrapping(감싸기) 방식으로, 런타임에 새로운 기능을 동적 덧붙일 수 있도록 설계된 기법입니다. 상속이 아닌 “구성(composition)을 통한 기능 확장”을 지향합니다.

### **등장 배경**

만약 상속만으로 기본 기능에 새로운 기능들을 추가하고자 한다면 아래와 같이 두가지의 방법을 사용할 수 있습니다.

- 추상 클래스에 새로운 기능들 추가
- 추상 클래스를 상속받아 새로운 추상 클래스 구현

위와 같이 구현할 경우 다음과 같은 문제가 발생할 수 있습니다.

- 추상 클래스에 새로운 기능들 추가: 해당 기능이 필요없는 구체 클래스도 해당 기능을 구현해야함(불필요한 코드 구현 필요)
- 추상 클래스를 상속받아 새로운 추상 클래스 구현: 클래스의 깊이가 깊어지거나

따라서 위처럼 상속만으로는 복합 기능을 유연하게 조합하기 어렵습니다. 따라서 상속보다는 구성을 통해 좀 더 유연한 확장을 구현하기 위해 데코레이터 패턴이 등장하였습니다.

![image](https://github.com/user-attachments/assets/4a866dc3-2fb5-4886-9dae-acda681e0d05)


### 핵심 아이디어

1. 먼저 사용한 인터페이스를 정의합니다. 이후 구현할 데코레이터 추상클래스, 기본 클래스에서 동일하게 이 인터페이스를 바라봅니다.
2. 정의한 인터페이스 기반 기본 클래스를 구현합니다.
3. 정의한 인터페이스 기반 데코레이터 추상 클래스를 구현합니다. 여기서 중요한 점은 기본 클래스 타입의 인스턴스를 내부 멤버로 보유한다는 것입니다.
4. 데코레이터의 구상 클래스를 구현하여 기능을 추가합니다.

### 실제 활용

기본 기능 인터페이스(A)로 정의

```jsx
// Component.ts
export interface Component {
  operation(): string;
}
```

기본 기능 인터페이스(A)로 기본 기능 클래스 = (B)

```jsx
// ConcreteComponent.ts
export class ConcreteComponent implements Component {
  operation(): string {
    return '기본 기능';
  }
}
```

기본 기능 인터페이스(A)로 데코레이터 추상클래스(C)

```jsx
// Decorator.ts
import { Component } from './Component';

export abstract class Decorator implements Component {
  protected component: Component;

  constructor(component: Component) {
    this.component = component;
  }

  operation(): string {
    return this.component.operation();
  }
}
```

데코레이터 추상클래스(C)의 구체클래스(D)

```jsx
// ConcreteDecoratorA.ts
import { Decorator } from './Decorator';

export class ConcreteDecoratorA extends Decorator {
  operation(): string {
    const baseResult = super.operation();
    return this.addBehavior(baseResult);
  }

  private addBehavior(input: string): string {
    return `${input} + 데코레이터A 기능`;
  }
}

// ConcreteDecoratorB.ts
import { Decorator } from './Decorator';

export class ConcreteDecoratorB extends Decorator {
  operation(): string {
    const baseResult = super.operation();
    return `${baseResult} + 데코레이터B 기능 전처리` + this.addExtra(baseResult);
  }

  private addExtra(input: string): string {
    return ` & 추가 기능(B)`;
  }
}

```

실제 사용

```jsx
import { ConcreteComponent } from './ConcreteComponent';
import { ConcreteDecoratorA } from './ConcreteDecoratorA';
import { ConcreteDecoratorB } from './ConcreteDecoratorB';

// 1) 기본 컴포넌트만 사용할 때
const simple = new ConcreteComponent();
console.log(simple.operation());
// 출력: '기본 기능'

// 2) 데코레이터A를 씌웠을 때
const decoratedA = new ConcreteDecoratorA(simple);
console.log(decoratedA.operation());
// 출력: '기본 기능 + 데코레이터A 기능'

// 3) 데코레이터A 위에 데코레이터B를 중첩했을 때
const decoratedAB = new ConcreteDecoratorB(decoratedA);
console.log(decoratedAB.operation());
// 출력: '기본 기능 + 데코레이터A 기능 + 데코레이터B 기능 전처리 & 추가 기능(B)'
```

```jsx
1. 먼저 사용한 인터페이스를 정의(데코레이터 추상클래스, 기본 클래스에서 동일하게 이 인터페이스를 바라봄)
2. 정의한 인터페이스 기반 기본 클래스를 구현한다
3. 정의한 인터페이스 기반 데코레이터 추상 클래스를 구현하다. 여기서 중요한건 기본 클래스 타입의 인스턴스를 내부 멤버로 보유한다는 것이다.
4. 데코레이터의 구상 클래스를 구현하여 기능을 추가한다.
```
